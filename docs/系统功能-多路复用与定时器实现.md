# 系统功能-多路复用与定时器实现

## 实现目标

为了支持更复杂的 I/O 模式和定时任务，V3.0 版本添加了两个重要功能：

1. **poll() 多路复用**：同时监控多个文件描述符，等待任意一个就绪
2. **alarm() 定时器**：设置定时信号，到期后发送 SIGALRM

这两个功能是很多实用程序的基础，比如 shell 的超时输入、网络服务器的事件循环等。

## 实现方案

### 1. poll() I/O 多路复用

#### 数据结构

```c
// kernel/sysfile.c
#define POLLIN   0x0001   // 可读
#define POLLOUT  0x0004   // 可写
#define POLLERR  0x0008   // 错误
#define POLLHUP  0x0010   // 挂起
#define POLLNVAL 0x0020   // 无效 fd

#define POLL_MAX_FDS 64

struct pollfd {
  int fd;         // 文件描述符
  short events;   // 请求的事件
  short revents;  // 返回的事件
};
```

#### 文件状态检查

不同类型的文件需要不同的就绪判断逻辑：

```c
// kernel/sysfile.c - file_poll()
static short file_poll(struct file *f)
{
  short revents = 0;
  
  switch(f->type) {
    case FD_PIPE: {
      struct pipe *pi = f->pipe;
      acquire(&pi->lock);
      
      if(f->readable) {
        if(pi->nread != pi->nwrite)  // 缓冲区有数据
          revents |= POLLIN;
        if(!pi->writeopen)           // 写端关闭
          revents |= POLLHUP;
      }
      
      if(f->writable) {
        if(pi->nwrite < pi->nread + PIPESIZE)  // 缓冲区有空间
          revents |= POLLOUT;
        if(!pi->readopen)            // 读端关闭
          revents |= POLLERR;
      }
      
      release(&pi->lock);
      break;
    }
    
    case FD_ENTRY:
      // 普通文件总是可读可写
      if(f->readable) revents |= POLLIN;
      if(f->writable) revents |= POLLOUT;
      break;
      
    case FD_SOCKET:
      revents = sockpoll(f->socket, ~0);
      break;
      
    default:
      revents |= POLLNVAL;
  }
  
  return revents;
}
```

#### sys_poll 实现

主循环：轮询所有 fd，有就绪或超时则返回：

```c
// kernel/sysfile.c - sys_poll()
uint64 sys_poll(void)
{
  struct pollfd fds[POLL_MAX_FDS];
  
  // 从用户空间复制 pollfd 数组
  copyin(p->pagetable, (char*)fds, fds_addr, nfds * sizeof(struct pollfd));
  
  uint start_ticks = ticks;
  int timeout_ticks = timeout / 100;  // ms 转 ticks (约 10ms/tick)
  
  while(1) {
    int ready = 0;
    
    // 检查所有 fd
    for(int i = 0; i < nfds; i++) {
      fds[i].revents = 0;
      
      if(fds[i].fd < 0) continue;  // 负 fd 被忽略
      
      struct file *f = p->ofile[fds[i].fd];
      if(f == 0) {
        fds[i].revents = POLLNVAL;
        ready++;
        continue;
      }
      
      short rev = file_poll(f);
      fds[i].revents = rev & (fds[i].events | POLLERR | POLLHUP | POLLNVAL);
      
      if(fds[i].revents != 0)
        ready++;
    }
    
    // 有就绪的 fd
    if(ready > 0) {
      copyout(p->pagetable, fds_addr, (char*)fds, nfds * sizeof(struct pollfd));
      return ready;
    }
    
    // 检查超时
    if(timeout == 0 || (ticks - start_ticks) >= timeout_ticks) {
      copyout(p->pagetable, fds_addr, (char*)fds, nfds * sizeof(struct pollfd));
      return 0;
    }
    
    // 等待一个 tick 再重试
    acquire(&tickslock);
    sleep(&ticks, &tickslock);
    release(&tickslock);
  }
}
```

### 2. alarm() 定时器

#### 进程字段

在 struct proc 中添加定时器到期时间：

```c
// kernel/include/proc.h
struct proc {
  uint alarm_ticks;  // 到期时刻 (0 = 禁用)
};
```

#### sys_alarm 实现

设置定时器，返回上次剩余时间：

```c
// kernel/sysproc.c - sys_alarm()
uint64 sys_alarm(void)
{
  int seconds;
  struct proc *p = myproc();
  
  argint(0, &seconds);
  if(seconds < 0) return -1;
  
  // 计算旧 alarm 的剩余时间
  uint remaining = 0;
  if(p->alarm_ticks > ticks) {
    remaining = (p->alarm_ticks - ticks) / 10;  // ticks 转秒
  }
  
  // 设置新 alarm
  if(seconds == 0) {
    p->alarm_ticks = 0;  // 取消定时器
  } else {
    p->alarm_ticks = ticks + seconds * 10;  // 秒转 ticks
  }
  
  return remaining;
}
```

#### 时钟中断检查

每次时钟中断检查是否有进程的定时器到期：

```c
// kernel/timer.c - timer_tick()
void timer_tick(void)
{
  struct proc *p;
  
  for(p = proc; p < &proc[NPROC]; p++) {
    if(p->state != UNUSED && p->alarm_ticks != 0) {
      if(ticks >= p->alarm_ticks) {
        // 发送 SIGALRM 信号
        p->sig_pending |= (1 << SIGALRM);
        p->alarm_ticks = 0;  // 单次定时
      }
    }
  }
}
```

定时器到期会给进程发送 SIGALRM 信号，进程可以用 sigaction 设置处理器。

## 遇到的问题

### 1. poll 的忙等待问题

最初 poll 是纯忙等待，CPU 占用 100%。改成通过 sleep(&ticks) 等待时钟中断，每个 tick 醒来检查一次。

### 2. 超时转换精度

xv6 的 ticks 约 10ms/tick，所以 1 秒 = 10 ticks。对于毫秒级 timeout 精度有限，但对于演示足够用。

```c
int timeout_ticks = (timeout < 0) ? 0x7fffffff : timeout / 100;
```

负 timeout 表示无限等待。

### 3. SIGALRM 与信号系统集成

alarm 触发的 SIGALRM 需要信号系统支持。确保进程在返回用户态时会检查 sig_pending 并处理信号。

## 测试结果

polltest 验证管道的 poll 行为：

```
$ polltest
Testing poll on pipe...
  poll() returned 1 (pipe readable)
  poll() returned 1 (pipe closed - POLLHUP)
Testing poll timeout...
  poll() with 100ms timeout returned 0 correctly
PASSED
```

alarmtest 验证定时信号：

```
$ alarmtest
Setting 1 second alarm...
Alarm fired after ~1000ms
PASSED
```

usertests 全部通过。
