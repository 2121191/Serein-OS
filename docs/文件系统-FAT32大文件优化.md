# FAT32 大文件支持与优化

## 背景

xv6-k210 使用 FAT32 文件系统，需要验证是否支持大文件（超过 10MB），以及解决可能存在的性能问题。

## 大文件验证

### 测试方法

写了个 `bigfile` 测试程序，循环写入数据到 bigfile.txt 直到 10MB，然后读取验证完整性。

### 测试结果

- 文件大小：10,485,760 bytes (10 MB)
- 写入耗时：472 ticks（QEMU 下约 47 秒）
- 数据完整性：校验通过

结论：原生 FAT32 实现支持大文件读写，没有硬编码限制。

## 性能问题

FAT32 用链表存储簇，顺序读写没问题，但随机访问有性能问题：

- 顺序读写：O(1)，因为 `struct dirent` 缓存了当前簇号
- 随机/向后访问：需要从头遍历 FAT 链表，10MB 文件有约 2560 个簇，每次跳转都是 O(N)

## 优化方案：稀疏簇索引

在内存中维护索引表，每隔 128 个簇记录一个"检查点"位置。

- 内存开销：每个打开的大文件占用 4KB（一次 kalloc）
- 覆盖范围：单个索引页可支持最大 512 MB 文件的 O(1) 随机访问
- 生命周期：随文件打开分配，关闭时释放

### 实现

在 `struct dirent` 中增加 `uint32 *index` 指针，`reloc_clus` 函数中随读写自动填充索引。跳转时先查索引找最近的检查点，再短距离线性查找。

## 优化效果

| 操作 | 优化前 | 优化后 |
|------|--------|--------|
| 写入 10MB | 472 ticks | 472 ticks（无额外开销）|
| 顺序读取 | 即时 | 即时 |
| 向后跳转 | ~20 ticks | 即时 |
| 随机访问 5MB | ~10 ticks | 4 ticks |

## 总结

通过稀疏簇索引（4KB/文件），消除了 FAT32 大文件随机访问的 O(N) 瓶颈。
