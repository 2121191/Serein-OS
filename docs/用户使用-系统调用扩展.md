# 用户使用-系统调用扩展

本文档介绍如何在 Serein 中添加自定义系统调用。

## 添加新系统调用的步骤

### 1. 定义系统调用号

在 `kernel/include/sysnum.h` 中添加新的系统调用号：

```c
// 在文件末尾添加（使用下一个可用编号）
#define SYS_mysyscall   76  // 你的系统调用
```

### 2. 实现系统调用处理函数

在对应的 `kernel/sys*.c` 文件中实现处理函数。根据功能选择文件：
- `sysproc.c` - 进程相关
- `sysfile.c` - 文件相关
- 或创建新文件

```c
// kernel/sysproc.c
uint64
sys_mysyscall(void)
{
  int arg1;
  
  // 获取参数
  if(argint(0, &arg1) < 0)
    return -1;
  
  // 实现逻辑
  printf("mysyscall called with arg=%d\n", arg1);
  
  return 0;  // 返回值
}
```

**常用参数获取函数**：
- `argint(n, &val)` - 获取第 n 个 int 参数
- `argaddr(n, &addr)` - 获取第 n 个地址参数
- `argstr(n, buf, size)` - 获取第 n 个字符串参数

### 3. 注册到系统调用表

在 `kernel/syscall.c` 中注册：

```c
// 1. 添加函数声明
extern uint64 sys_mysyscall(void);

// 2. 添加到 syscalls 数组（按编号位置）
static uint64 (*syscalls[])(void) = {
  // ...
  [SYS_mysyscall] sys_mysyscall,
};
```

### 4. 添加用户态接口

在 `serein-user/usys.pl` 中添加一行：

```perl
entry("mysyscall");
```

在 `serein-user/user.h` 中添加函数声明：

```c
int mysyscall(int arg);
```

### 5. 编写测试程序

创建 `serein-user/testmysyscall.c`：

```c
#include "kernel/include/types.h"
#include "serein-user/user.h"

int main(void)
{
  int ret = mysyscall(42);
  printf("mysyscall returned: %d\n", ret);
  exit(0);
}
```

将其添加到 `Makefile` 的 `UPROGS`：

```makefile
UPROGS=\
    ...
    $U/_testmysyscall\
```

### 6. 编译测试

```bash
make clean
make fs
make run
```

在 shell 中运行：
```bash
testmysyscall
```

## 完整示例：获取进程票数

以下是一个完整的系统调用示例，获取当前进程的 Stride 调度票数：

**sysnum.h**:
```c
#define SYS_gettickets  78
```

**sysproc.c**:
```c
uint64
sys_gettickets(void)
{
  return myproc()->tickets;
}
```

**syscall.c**:
```c
extern uint64 sys_gettickets(void);
[SYS_gettickets] sys_gettickets,
```

**usys.pl**:
```perl
entry("gettickets");
```

**user.h**:
```c
int gettickets(void);
```

## 参考资料

- 现有系统调用实现：`kernel/sysproc.c`, `kernel/sysfile.c`
- 系统调用号定义：`kernel/include/sysnum.h`
- 用户态封装生成：`serein-user/usys.pl`
