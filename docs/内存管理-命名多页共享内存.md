# 内核原理-内存管理-命名多页共享内存

## 1. 工作概述 
原版 xv6-k210 内核缺少一个可直接供用户态使用的共享内存机制。为支持跨进程高效共享数据，我们在内核中新增了一个 **命名、多页共享内存（Shared Memory, SHM）子系统**，并通过系统调用提供给用户程序。

本次新增/改动的核心文件：
- 内核实现：`kernel/shm.c`
- 系统调用封装：`kernel/sysshm.c`
- 相关集成：进程退出路径调用 `shmdetach_all`（位于 `kernel/proc.c` 的页表释放流程）
- 用户态测试：`xv6-user/tests/shmtest1.c`、`xv6-user/tests/shmtest2.c`

---

## 2. 问题发现 
原版系统在进程间通信方面主要依赖管道等机制，但缺少一种“共享同一段物理内存”的方式，因此：
- 跨进程共享大块数据需要拷贝，开销较大。
- 无法方便地验证/支撑一些典型的共享内存使用场景（例如共享缓冲区、共享状态）。

---

## 3. 解决方案
### 3.1 命名 + 多页共享段
该实现引入“按名字管理”的共享内存段：
- `shmcreate(name, size)`：创建共享段（`size` 换算为页数，至少 1 页，受 `SHM_MAX_PAGES` 限制）
- `shmopen(name)`：通过名字打开并获取 `shmid`

共享段由多页物理页数组构成（可非连续），从而支持“多页 SHM”。

### 3.2 映射/解除映射 + 固定虚拟地址窗口（与实现一致）
为简化地址管理，本实现采用 **预留虚拟地址区间** 的策略：
- `shmattach(shmid)`：把共享段映射到进程地址空间中一段固定的 SHM 虚拟地址窗口（按 `shmid` 计算基址），并增加引用计数。
- `shmdetach(va, size)`：按映射基址解除映射，并减少引用计数。

并且在映射前会做：
- SHM 虚拟地址区间边界检查
- 目标区间是否已被占用（映射冲突）检查

### 3.3 引用计数 + unlink 语义
该实现提供 `shmunlink(name)`，并实现了常见的 unlink 语义：
- unlink 后“名字 → 段”的关联被删除，后续不能再通过 name 打开。
- 若仍有进程已经 attach，该段仍可继续使用。
- 当最后一个进程 detach 且该段已 unlink 后，才真正释放物理页。

该语义通过共享段的引用计数（refcnt）实现，确保生命周期管理清晰。

### 3.4 失败回滚与进程退出自动分离
为保证稳定性，该实现重点处理了两类资源回收场景：

1) **attach 失败回滚**
- 若映射过程中失败，只撤销已建立的页表映射（unmap），并明确不释放共享段持有的物理页，避免误释放导致的错误。

2) **进程退出自动分离**
- 在进程页表释放路径中调用 `shmdetach_all(pagetable)`，确保进程退出时自动解除其持有的共享映射，避免映射泄漏与引用计数悬挂。

---

## 4. 测试与验证
为验证该模块，新增了两个用户态测试：
- `shmtest1.c` / `shmtest2.c`

测试覆盖重点包括：
- create/open/attach/detach 基本流程
- 跨进程写入后读出可见性
- unlink 后已 attach 仍可使用、最终 detach 后可回收的语义

---

## 5. 小结 
综上，张尚昆同学在原 xv6-k210 的基础上实现了一个 **命名、多页、具备引用计数与 unlink 语义** 的共享内存子系统，并补齐了失败回滚与进程退出自动分离机制。该能力在原版内核中不存在，且通过 `shmtest1/shmtest2` 完成了核心行为验证。
