# 进程间通信-信号量与共享内存实现

## 实现目标

xv6 原版只有 pipe 一种 IPC 机制，无法满足更复杂的进程同步需求。这个模块实现了两种经典的 IPC 机制：

1. **信号量 (Semaphore)**：用于进程同步，支持 P/V 操作
2. **共享内存 (Shared Memory)**：多进程共享同一块物理内存，高效传递大量数据

## 实现方案

### 1. 信号量

#### 数据结构

```c
// kernel/include/sem.h
#define NSEM 32  // 最多 32 个信号量

struct sem {
  struct spinlock lock;
  int count;                    // 信号量值（可为负数）
  int ref;                      // 引用计数
  char name[16];                // 名称（调试用）
  struct proc *waiters[NPROC];  // 等待队列
  int nwaiters;                 // 等待进程数
};

// kernel/sem.c
struct sem sems[NSEM];
struct spinlock sem_table_lock;
```

信号量表用全局数组实现，每个信号量有独立的自旋锁。

#### 核心操作

P 操作 (semwait)：

```c
// kernel/sem.c - semwait()
void semwait(struct sem *sem)
{
  acquire(&sem->lock);
  sem->count--;
  if(sem->count < 0) {
    // 加入等待队列
    struct proc *p = myproc();
    if(sem->nwaiters < NPROC) {
      sem->waiters[sem->nwaiters++] = p;
    }
    // 阻塞，等待 V 操作唤醒
    sleep(sem, &sem->lock);
  }
  release(&sem->lock);
}
```

V 操作 (sempost)：

```c
// kernel/sem.c - sempost()
void sempost(struct sem *sem)
{
  acquire(&sem->lock);
  sem->count++;
  if(sem->count <= 0) {
    // 有等待者，唤醒一个
    wakeup(sem);
  }
  release(&sem->lock);
}
```

#### 系统调用接口

```c
// 系统调用
sem_open(initial_value)   // 创建或打开信号量
sem_wait(sem_id)          // P 操作
sem_post(sem_id)          // V 操作
sem_close(sem_id)         // 关闭引用
sem_getvalue(sem_id)      // 获取当前值
```

### 2. 共享内存

#### 数据结构

```c
// kernel/include/shm.h
#define NSHM 16              // 最多 16 个共享段
#define SHM_MAX_PAGES 16     // 每段最多 16 页 (64KB)
#define SHM_NAME_MAX 32

struct shm {
  char name[SHM_NAME_MAX];
  void *pa[SHM_MAX_PAGES];   // 物理页数组
  int npages;
  uint64 size;
  int ref;                   // 引用计数
  int shmid;                 // 唯一标识
  struct spinlock lock;
};
```

共享内存段分配非连续的物理页，但映射到进程虚拟地址空间的连续区域。

#### shmcreate 实现

创建共享内存段并分配物理页：

```c
// kernel/shm.c - shmcreate()
int shmcreate(char *name, uint64 size)
{
  struct shm *shm = shmalloc();  // 找空闲槽
  
  int npages = PGROUNDUP(size) / PGSIZE;
  if(npages > SHM_MAX_PAGES)
    return -1;
  
  // 分配物理页
  for(int i = 0; i < npages; i++) {
    void *pa = kalloc();
    shm->pa[i] = pa;
    memset(pa, 0, PGSIZE);
  }
  
  strncpy(shm->name, name, SHM_NAME_MAX);
  shm->size = size;
  shm->npages = npages;
  shm->ref = 1;
  shm->shmid = next_shmid++;
  
  return shm->shmid;
}
```

#### shmattach 实现

把共享内存映射到进程地址空间：

```c
// kernel/shm.c - shmattach()
// 共享内存虚拟地址空间: 0x40000000 - 0x50000000
#define SHM_VA_BASE   0x40000000UL
#define SHM_VA_STRIDE (SHM_MAX_PAGES * PGSIZE)

uint64 shmattach(int shmid, pagetable_t pagetable)
{
  struct shm *shm = shmget(shmid);
  
  // 根据 shmid 计算固定虚拟地址
  uint64 va = SHM_VA_BASE + (shmid - 1) * SHM_VA_STRIDE;
  
  // 映射每个物理页到连续虚拟页
  for(int i = 0; i < shm->npages; i++) {
    mappages(pagetable, va + i * PGSIZE, PGSIZE,
             (uint64)shm->pa[i], PTE_W|PTE_R|PTE_U);
  }
  
  shm->ref++;
  return va;
}
```

每个 shmid 有固定的虚拟地址范围，这样不同进程对同一 shmid 的 attach 会映射到相同虚拟地址。

#### shmdetach 和进程退出处理

detach 时只解除映射，不释放物理页（物理页归共享段所有）：

```c
// kernel/shm.c - shmdetach()
int shmdetach(uint64 va, pagetable_t pagetable, uint64 size)
{
  int idx = (va - SHM_VA_BASE) / SHM_VA_STRIDE + 1;
  struct shm *shm = shmget(idx);
  
  // 解除映射，不释放物理页
  vmunmap(pagetable, va, shm->npages, 0);
  
  shm->ref--;
  if(shm->ref == 0 && shm->name[0] == '\0') {
    // 已 unlink 且无引用，释放物理页
    shmfree(shm);
  }
  return 0;
}
```

进程退出时需要清理共享内存映射：

```c
// kernel/shm.c - shmdetach_all()
void shmdetach_all(pagetable_t pagetable)
{
  for(shm = shmtable.shm; shm < shmtable.shm + NSHM; shm++) {
    if(shm->shmid == 0) continue;
    uint64 va = SHM_VA_BASE + (shm->shmid - 1) * SHM_VA_STRIDE;
    if(walkaddr(pagetable, va) != 0) {
      shmdetach(va, pagetable, shm->size);
    }
  }
}
```

#### 系统调用接口

```c
shmcreate(name, size)    // 创建共享段
shmopen(name)            // 打开已有共享段
shmattach(shmid)         // 映射到进程空间
shmdetach(addr, size)    // 解除映射
shmunlink(name)          // 标记删除（待所有引用释放后真正删除）
```

## 遇到的问题

### 1. 共享内存虚拟地址冲突

最初每个进程的 shm 从当前 p->sz 开始分配，不同进程得到不同地址，写入数据后另一个进程读不到。

解决方案：使用固定的 VA 范围 (0x40000000 - 0x50000000)，每个 shmid 有固定偏移。

### 2. 进程退出时的引用计数

进程异常退出时如果没清理 shm 映射，引用计数永远不会归零。在 exit() 中添加 shmdetach_all 调用：

```c
// kernel/proc.c - exit()
void exit(int status)
{
  // 清理共享内存映射
  shmdetach_all(p->pagetable);
  // ...
}
```

### 3. 死锁：sem_table_lock 与 sem->lock

原来在 semfree 中先持 sem_table_lock 再持 sem->lock，但 wakeup 内部可能需要持其他锁。重新调整锁顺序，确保 sem->lock 在 sem_table_lock 之后释放。

## 测试结果

semtest 验证生产者消费者同步：

```
$ semtest
Producer: sending 100 items...
Consumer: received 100 items correctly
PASSED
```

shmtest 验证共享内存通信：

```
$ shmtest
Parent writes: "Hello from parent"
Child reads:   "Hello from parent"
Child writes:  "Response from child"
Parent reads:  "Response from child"
PASSED
```

usertests 全部通过。
